-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compile-time CAS(Computer Algebra System)
--   
--   Compile-time CAS(Computer Algebra System)
@package th-cas
@version 0.2.0

module Algebra.CAS.Base

-- | Mathematical constant expression
data Const

-- | Zero
Zero :: Const

-- | One
One :: Const

-- | Integer
CI :: Integer -> Const

-- | Faction = CF numer denom
CF :: Integer -> Integer -> Const

-- | Real Number
CR :: Double -> Const
neg :: Const
constSimplify :: Const -> Const
toInt :: Const -> Maybe Integer
mapTuple :: (a -> b) -> (a, a) -> (b, b)
data SpecialFunction
Sin :: Formula -> SpecialFunction
Cos :: Formula -> SpecialFunction
Tan :: Formula -> SpecialFunction
Sinh :: Formula -> SpecialFunction
Cosh :: Formula -> SpecialFunction
Tanh :: Formula -> SpecialFunction
Asin :: Formula -> SpecialFunction
Acos :: Formula -> SpecialFunction
Atan :: Formula -> SpecialFunction
Asinh :: Formula -> SpecialFunction
Acosh :: Formula -> SpecialFunction
Atanh :: Formula -> SpecialFunction
Exp :: Formula -> SpecialFunction
Log :: Formula -> SpecialFunction
Abs :: Formula -> SpecialFunction
Sig :: Formula -> SpecialFunction
LogBase :: Formula -> Formula -> SpecialFunction
Sqrt :: Formula -> SpecialFunction
Diff :: Formula -> Formula -> SpecialFunction
Integrate :: Formula -> Formula -> SpecialFunction

-- | Mathematical expression
data Formula

-- | Constant value
C :: Const -> Formula

-- | Pi
Pi :: Formula

-- | Imaginary Number
I :: Formula

-- | Constant variable which is used to deal variable(V Name) as constant
--   value
CV :: String -> Formula

-- | Variable
V :: String -> Formula

-- | Special Functions (sin, cos, exp and etc..)
S :: SpecialFunction -> Formula
(:^:) :: Formula -> Formula -> Formula
(:*:) :: Formula -> Formula -> Formula
(:+:) :: Formula -> Formula -> Formula
(:/:) :: Formula -> Formula -> Formula
(=:) :: Formula -> Formula -> Formula
infix 0 =:
tryPlus :: Formula -> Formula -> Maybe Formula
insertPlus :: Formula -> Formula -> Formula

-- | try simplification for multiply
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y] = map V ["x","y"]
--   
--   &gt;&gt;&gt; tryMul (x**(-1)) x
--   Just 1
--   </pre>
tryMul :: Formula -> Formula -> Maybe Formula
insertMul :: Formula -> Formula -> Formula
constDiv :: Formula -> Formula -> Formula
splitExp :: Formula -> (Formula, Formula)
divGB :: Formula -> Formula -> Formula
divGB' :: Formula -> Formula -> Formula
divAll :: Formula -> Formula -> Formula

-- | Lift String to variable of Formula
val :: String -> Formula

-- | Lift String to constant of Formula
cval :: String -> Formula
lcmMonomial :: Formula -> Formula -> Formula
lcmMonomial' :: Formula -> Formula -> Formula
reduction :: Formula -> Formula -> (Formula, Formula)
reductions :: Formula -> [Formula] -> Formula
degree :: Formula -> Formula
converge :: (Formula -> Formula) -> Formula -> Formula

-- | try to reduce a variable. &gt;&gt;&gt; let [a,b,c] = map CV
--   ["a","b","c"] &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   &gt;&gt;&gt; let [f0,f1] = [(2*x+4*y+4),(x-2*y+1)] &gt;&gt;&gt; f0*f1
--   (1 + x + (-2)*y)*(4 + 2*x + 4*y) &gt;&gt;&gt; expand $ f0*f1 4 + 6*x +
--   2*(x^2) + (-4)*y + (-8)*(y^2) &gt;&gt;&gt; expand $ (a*x-2*b*y+c) c +
--   a*x + (-2)*b*y &gt;&gt;&gt; expand $ - ((-2*b)/(4*b))
--   (-1)*(((-2)*b)/(4*b)) &gt;&gt;&gt; expand $ -
--   ((-2*b)/(4*b))*(2*a*x+4*b*y+4*c) (-4)*(((-2)*b)<i>(4*b))*c +
--   (-2)*a*(((-2)*b)</i>(4*b))*x + (-4)*(((-2)*b)/(4*b))*b*y &gt;&gt;&gt;
--   expand $ (a*x-2*b*y+c) - ((-2*b)/(4*b))*(2*a*x+4*b*y+4*c) c +
--   (-4)*c*(((-2)*b)<i>(4*b)) + a*x + (-2)*(((-2)*b)</i>(4*b))*a*x +
--   (-4)*b*(((-2)*b)/(4*b))*y + (-2)*b*y
expand :: Formula -> Formula
expand' :: Int -> Formula -> Formula
expandIO :: Formula -> IO Formula
gcdPolynomial :: Formula -> Formula -> Formula
lcmPolynomial :: Formula -> Formula -> Formula
headAdd :: Formula -> Formula
tailAdd :: Formula -> Formula
mapAdd :: (Formula -> Formula) -> Formula -> Formula
splitAdd :: Formula -> [Formula]
headMul :: Formula -> Formula
tailMul :: Formula -> Formula
headDiv :: Formula -> Formula
tailDiv :: Formula -> Maybe Formula

-- | substitute expression
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; subst [(x,3),(y,5)] $ x+y
--   8
--   
--   &gt;&gt;&gt; subst [(tan(x),z)] (tan(x)**2+1)
--   1 + z^2
--   </pre>
subst :: [(Formula, Formula)] -> Formula -> Formula
subst' :: Formula -> Formula -> Formula -> Formula
mapFormula :: (Formula -> Formula) -> Formula -> Formula

-- | When formula does not include variable, isConst returns True.
--   
--   <pre>
--   &gt;&gt;&gt; let x = "x" :: Formula
--   
--   &gt;&gt;&gt; isConst x
--   False
--   
--   &gt;&gt;&gt; isConst $ sin(x)*3
--   False
--   
--   &gt;&gt;&gt; isConst $ 3.0 * sin(3.0)
--   True
--   </pre>
isConst :: Formula -> Bool
hasVariable :: Formula -> Formula -> Bool
isVariable :: Formula -> Bool
variables :: Formula -> [Formula]
denom :: Formula -> Formula
numer :: Formula -> Formula
headV :: Formula -> (Formula, Formula)

-- | Pretty print for Formula type. Formula's show function is the same as
--   this.
ppr :: Formula -> String
ppr' :: Formula -> String

-- | This print shows bare structure of Formula type. This string can be
--   read by Formula's read function.
showFormula :: Formula -> String
genCoeff :: String -> Int -> [Formula]
genVars :: String -> Int -> [Formula]

-- | Find indeterminates of an expression
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; indets (x*y+z/x)
--   [x,y,z]
--   
--   &gt;&gt;&gt; indets (3*x^2-x*y-y^2)
--   [x,y]
--   
--   &gt;&gt;&gt; indets (sin(x)*cos(x)**2)
--   [sin(x),x,cos(x)]
--   </pre>
indets :: Formula -> [Formula]
indets' :: Formula -> [Formula]
maskVariables :: Formula -> Formula -> (Formula, Formula -> Formula)

-- | Greatest common divisor of the coefficients of formula with respect to
--   variable of second function-args
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y] = map V ["x","y"]
--   
--   &gt;&gt;&gt; content (-4*x*y+6*y^2) x
--   ((-4)*y,x + (3/-2)*y)
--   </pre>
content :: Formula -> Formula -> (Formula, Formula)
instance GHC.Classes.Ord Algebra.CAS.Base.SpecialFunction
instance GHC.Classes.Eq Algebra.CAS.Base.SpecialFunction
instance GHC.Read.Read Algebra.CAS.Base.SpecialFunction
instance GHC.Show.Show Algebra.CAS.Base.SpecialFunction
instance GHC.Read.Read Algebra.CAS.Base.Formula
instance GHC.Classes.Eq Algebra.CAS.Base.Formula
instance GHC.Read.Read Algebra.CAS.Base.Const
instance GHC.Show.Show Algebra.CAS.Base.Const
instance GHC.Classes.Eq Algebra.CAS.Base.Const
instance GHC.Classes.Ord Algebra.CAS.Base.Formula
instance GHC.Num.Num Algebra.CAS.Base.Formula
instance GHC.Real.Fractional Algebra.CAS.Base.Formula
instance GHC.Float.Floating Algebra.CAS.Base.Formula
instance Data.String.IsString Algebra.CAS.Base.Formula
instance GHC.Enum.Enum Algebra.CAS.Base.Formula
instance GHC.Real.Real Algebra.CAS.Base.Formula
instance GHC.Real.Integral Algebra.CAS.Base.Formula
instance GHC.Show.Show Algebra.CAS.Base.Formula
instance GHC.Classes.Ord Algebra.CAS.Base.Const
instance GHC.Num.Num Algebra.CAS.Base.Const
instance GHC.Real.Fractional Algebra.CAS.Base.Const
instance GHC.Enum.Enum Algebra.CAS.Base.Const
instance GHC.Real.Real Algebra.CAS.Base.Const
instance GHC.Float.Floating Algebra.CAS.Base.Const
instance GHC.Real.Integral Algebra.CAS.Base.Const

module Algebra.CAS.Diff

-- | Partial derivative
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y] = map V ["x","y"]
--   
--   &gt;&gt;&gt; diff (x*y) x
--   y
--   
--   &gt;&gt;&gt; diff (sin(x)*y) x
--   y*(cos(x))
--   
--   &gt;&gt;&gt; diff (x^3) x
--   3*(x^2)
--   </pre>
diff :: Formula -> Formula -> Formula
diffn :: Integer -> Formula -> Formula -> Formula

module Algebra.CAS.GrobnerBasis
sPolynomial :: Formula -> Formula -> Formula
allPair :: [t] -> [(t, t)]
grobnerG :: [Formula] -> [Formula]
grobnerBasis :: [Formula] -> [Formula]
grobnerBasis' :: [Formula] -> [(Formula, Formula)] -> [Formula]
grobnerBasisIO :: [Formula] -> IO [Formula]
grobnerBasisIO' :: [Formula] -> [(Formula, Formula)] -> IO [Formula]

module Algebra.CAS.Integrate

-- | integrate function
--   
--   <pre>
--   &gt;&gt;&gt; let x = V "x"
--   
--   &gt;&gt;&gt; integrate x x
--   (1/2)*(x^2)
--   
--   &gt;&gt;&gt; integrate (x^2) x
--   (1/3)*(x^3)
--   
--   &gt;&gt;&gt; integrate (sin x) x
--   (-1)*(cos(x))
--   </pre>
integrate :: Formula -> Formula -> Formula

-- | get terms of formula
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y] = map V ["x","y"]
--   
--   &gt;&gt;&gt; terms x x
--   [x]
--   
--   &gt;&gt;&gt; terms y x
--   []
--   
--   &gt;&gt;&gt; terms (sin x) x
--   [x,sin(x),cos(x)]
--   
--   &gt;&gt;&gt; terms (1/(sin x)) x
--   [x,sin(x),cos(x)]
--   </pre>
terms :: Formula -> Formula -> [Formula]

-- | combination for candidate formula
--   
--   <pre>
--   &gt;&gt;&gt; genPow 1 3
--   [[0,0,0],[0,0,1],[0,1,0],[1,0,0]]
--   
--   &gt;&gt;&gt; genPow 2 3
--   [[0,0,0],[0,0,1],[0,0,2],[0,1,0],[0,1,1],[0,2,0],[1,0,0],[1,0,1],[1,1,0],[2,0,0]]
--   </pre>
genPow :: Int -> Int -> [[Int]]

-- | degree for candidate formula
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y] = map V ["x","y"]
--   
--   &gt;&gt;&gt; candidateDegree 3 x
--   1
--   
--   &gt;&gt;&gt; candidateDegree (sin x) x
--   2
--   
--   &gt;&gt;&gt; candidateDegree (x**2) x
--   3
--   </pre>
candidateDegree :: Formula -> Formula -> Int

-- | candidate formula
--   
--   <pre>
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; candidateFormula [x,y,z] 2
--   a0 + a6*x + a9*(x^2) + a3*y + a8*x*y + a5*(y^2) + a1*z + a7*x*z + a4*y*z + a2*(z^2)
--   </pre>
candidateFormula :: [Formula] -> Int -> Formula

-- | derivation of candidate formula
--   
--   <pre>
--   &gt;&gt;&gt; let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
--   
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; let candidate = a0 + a6*x + a9*(x^2) + a3*y + a8*x*y + a5*(y^2) + a1*z + a7*x*z + a4*y*z + a2*(z^2)
--   
--   &gt;&gt;&gt; derivationCandidate [x,y,z] [1,z,-y] candidate
--   a6 + 2*a9*x + a8*y + a7*z + (-1)*y*(a1 + a7*x + a4*y + 2*a2*z) + z*(a3 + a8*x + 2*a5*y + a4*z)
--   
--   &gt;&gt;&gt; expand $ (derivationCandidate [x,y,z] [1,z,-y] candidate ) - y
--   a6 + 2*a9*x + (-1)*y + (-1)*a1*y + a8*y + (-1)*a7*x*y + (-1)*a4*(y^2) + a3*z + a7*z + a8*x*z + (-2)*a2*y*z + 2*a5*y*z + a4*(z^2)
--   </pre>
derivationCandidate :: [Formula] -> [Formula] -> Formula -> Formula

-- | split formula by coeff and vars
--   
--   <pre>
--   &gt;&gt;&gt; let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
--   
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; let f = a6 + 2*a9*x + (-1)*y + (-1)*a1*y + a8*y + (-1)*a7*x*y + (-1)*a4*(y^2) + a3*z + a7*z + a8*x*z + (-2)*a2*y*z + 2*a5*y*z + a4*(z^2)
--   
--   &gt;&gt;&gt; splitCoeffAndVariable f
--   [(a6,1),(2*a9,x),(-1 + (-1)*a1 + a8,y),((-1)*a7,x*y),((-1)*a4,y^2),(a3 + a7,z),(a8,x*z),((-2)*a2 + 2*a5,y*z),(a4,z^2)]
--   </pre>
splitCoeffAndVariable :: Formula -> [(Formula, Formula)]

-- | convert coefficient to variable
--   
--   <pre>
--   &gt;&gt;&gt; let [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genCoeff "a" 10
--   
--   &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   
--   &gt;&gt;&gt; let f = [(a6,1),(2*a9,x),(-1 + (-1)*a1 + a8,y),((-1)*a7,x*y),((-1)*a4,y^2),(a3 + a7,z),(a8,x*z),((-2)*a2 + 2*a5,y*z),(a4,z^2)]
--   
--   &gt;&gt;&gt; map coeffToVariable $ map fst f
--   [a6,2*a9,-1 + (-1)*a1 + a8,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4]
--   </pre>
coeffToVariable :: Formula -> Formula
splitFactor :: Formula -> Formula -> (Formula, Formula)

-- | integrate function of rischNorman-algorithm This is under development.
rischNorman' :: Formula -> Formula -> Formula

module Algebra.CAS.Solve

-- | compare a pair of formula and output matched variables &gt;&gt;&gt;
--   let [a,b,c] = map CV ["a","b","c"] &gt;&gt;&gt; let [x,y,z] = map V
--   ["x","y","z"] &gt;&gt;&gt; match (a*x+b) (2*x+3) Just [(b,3),(a,2)]
--   &gt;&gt;&gt; match (a*x^2+b) (2*x^2+3) Just [(b,3),(a,2)] &gt;&gt;&gt;
--   match (a*x^2+b*x+c) (2*x^2+4*x+3) Just [(c,3),(b,4),(a,2)]
--   &gt;&gt;&gt; match (a*x^2+b*x+c) (4*x+3) Nothing
match :: Formula -> Formula -> Maybe [(Formula, Formula)]
solve1 :: Formula -> Formula -> Maybe [Formula]
solve2 :: Formula -> Formula -> Maybe [Formula]
solve :: Formula -> Formula -> Maybe [Formula]

-- | solve linear equations &gt;&gt;&gt; let
--   [a0,a1,a2,a3,a4,a5,a6,a7,a8,a9] = reverse $ genVars "a" 10
--   &gt;&gt;&gt; let equations = [a6,2*a9,-1 + a8 +
--   (-1)*a1,(-1)*a7,(-1)*a4,a3 + a7,a8,(-2)*a2 + 2*a5,a4] &gt;&gt;&gt;
--   equations [a6,2*a9,-1 + (-1)*a1 + a8,(-1)*a7,(-1)*a4,a3 +
--   a7,a8,(-2)*a2 + 2*a5,a4] &gt;&gt;&gt; linsolve [head equations] Just
--   [(a6,0)] &gt;&gt;&gt; linsolve $ equations ++ [a0,a2] Just
--   [(a0,0),(a1,-1),(a2,0),(a3,0),(a4,0),(a5,0),(a6,0),(a7,0),(a8,0),(a9,0)]
linsolve :: [Formula] -> Maybe [(Formula, Formula)]

-- | try to reduce a variable. &gt;&gt;&gt; let [a,b,c] = map CV
--   ["a","b","c"] &gt;&gt;&gt; let [x,y,z] = map V ["x","y","z"]
--   &gt;&gt;&gt; let [f0,f1] = [(2*x+4*y+4),(x-2*y+1)] &gt;&gt;&gt;
--   lReduction f0 f1 3 + 2*x &gt;&gt;&gt; headV (2*a*x+4*b*y+4*c) (4*b,y)
--   &gt;&gt;&gt; headV (a*x-2*b*y+c) ((-2)*b,y) &gt;&gt;&gt; (a*x-2*b*y+c)
--   - ((-2*b)/(4*b))*(2*a*x+4*b*y+4*c) c + a*x + (-2)*b*y +
--   (-1)*(((-2)*b)/(4*b))*(4*c + 2*a*x + 4*b*y)
lReduction :: Formula -> Formula -> Formula
lReductions :: [Formula] -> [Formula]
rSolve :: [Formula] -> [(Formula, Formula)]

module Algebra.CAS

module Algebra.CAS.TH
exp2val :: Exp -> Formula
val2exp :: Formula -> Exp
lift :: Formula -> Exp
lift1 :: (Formula -> Formula) -> Exp -> Exp
lift2 :: (Formula -> Formula -> Formula) -> Exp -> Exp -> Exp
lift3 :: (Formula -> Formula -> Formula -> Formula) -> Exp -> Exp -> Exp -> Exp
prettyPrint :: Formula -> String
diff :: Q Exp -> Q Exp -> Q Exp
